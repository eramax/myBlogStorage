{"date":1635099391,"cats":[0,14,17,18],"content":"<p>GENERAL\n</p><p></p><div><div><span>-</span><span>My code reads like a narrative. I write code for humans, not machines.</span></div><div><span>-</span><span>I document my code only when necessary. My code should speak for itself.</span></div><div><span>-</span><span>I provide clear instructions on how to build and release my codebase. Where appropriate, I provide working build scripts/make files or CI/CD setup instructions.</span></div><div><span>-</span><span>I use native functionalities instead of implementing my own libraries, unless for a very good reason.</span></div><div><span>-</span><span>My code is consistent in its design patterns, documentation, and naming conventions. I do not change things mid-development and go against established patterns.</span></div><div><span>-</span><span>I have added logging to my application, so I or other developers can debug when things go awry.</span></div></div><br><p></p><p><br></p><div><div><span>CLASSES</span></div><div><span>-&nbsp;</span><span>My class has the strictest access modifier possible.</span></div><div><span>-&nbsp;</span><span>My class is named accurately.</span></div><div><span>-&nbsp;</span><span>My class performs operations on only one specific object and, therefore,</span></div><div><span>adheres to the single-responsibility principle.</span></div><div><span>-&nbsp;</span><span>My class lives in the right folder within my project.</span></div><div><span>-&nbsp;</span><span>If I struggle with implementing my class, I take a step back and come up with a&nbsp;</span><span>brief description of the class and its intended functionality. This refocus can&nbsp;</span><span>help write cleaner code. If my class should do multiple things, I split it up.</span></div><br><div><span>METHODS</span></div><div><span>-&nbsp;</span><span>My method has the strictest access modifier possible.</span></div><div><span>-&nbsp;</span><span>My method is named accurately and correctly describes the logic within (leaving</span><span>&nbsp;nothing out).</span></div><div><span>-&nbsp;</span><span>My method performs only one general operation or collects information from&nbsp;</span><span>other methods related to its operations. It adheres to the single-responsibility&nbsp;</span><span>principle.</span></div><div><span>-&nbsp;</span><span>If my method has a public access modifier, I do not perform any operations&nbsp;</span><span>within the method. The public method calls other, smaller, methods and orga</span><span>nizes the outputs.</span></div><div><span>-&nbsp;</span><span>I have unit tests backing my method. The unit tests should cover the major suc</span><span>cess and failure logic branches.</span></div><br><div><span>VARIABLES, FIELDS, AND PROPERTIES (VFP)</span></div><div><span>-&nbsp;</span><span>My VFP types are of the most abstract type possible. If I can use an interface&nbsp;</span><span>instead of a concrete type, I use the interface. This promotes polymorphism&nbsp;</span><span>and the use of the Liskov substitution principle.</span></div><div><span>-&nbsp;</span><span>I do not have any \u201cmagic numbers\u201d assigned to a variable.</span></div><div><span>-&nbsp;</span><span>Whenever possible, I restrict my VFPs to the tightest access modifier possible. If&nbsp;</span><span>a VFP can be made read-only, I make it read-only. If a VFP can be made a con</span><span>stant, I make it a constant.</span></div><div><span>-&nbsp;</span><span>I always validate my input arguments. This protects me against unwanted null&nbsp;</span><span>pointer exceptions and operating on data in an invalid state.</span></div><div><span>-&nbsp;</span><span>I use enums and constants instead of string literals where appropriate.</span></div><p><br></p><div><span>TESTING</span></div><div><span>-&nbsp;</span><span>I always provide appropriate unit tests to my code.</span></div><div><span>-&nbsp;</span><span>I follow test-driven development where possible.</span></div><div><span>-&nbsp;</span><span>I am not focused on code coverage. My goal in testing is to protect against&nbsp;</span><span>unexpected side effects and to validate my assumptions about the requirements&nbsp;</span><span>and existing code.</span></div><div><span>-&nbsp;</span><span>If one of my changes breaks a test, I fix the test.</span></div><div><span>-&nbsp;</span><span>I always write the least amount of code necessary to satisfy all tests. Any extrane</span><span>ous lines increase the amount of code to maintain.</span></div></div><p><br></p><p><br></p><p>Source :&nbsp;Jort Rodenburg - Code like a Pro in C#</p>","title":"Clean code checklist ","slug":"clean-code-checklist-b42l"}