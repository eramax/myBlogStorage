{"date":1662884394,"cats":[0,6,15,17,18,23,24],"content":"<p>Today we're open sourcing pg_graphql, a work-in-progress native PostgreSQL extension adding GraphQL support. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database server requiring no external services.</p><p><br></p><p>pg_graphql inspects an existing PostgreSQL schema and reflects a GraphQL schema with resolvers that are:</p><h2>performant</h2><ul><li><p>always up-to-date</p></li><li><p>compliant with best practices</p></li><li><p>serverless</p></li><li><p>open source</p></li></ul><h2>Motivation</h2><p>The Supabase stack is centered around PostgreSQL as the single source of truth. All data, configuration, and security are housed in the database so any GraphQL solution needed to be equivalently SQL-centric.</p><p><br></p><p>With that in mind, we took a look at the landscape and considered two excellent technologies, Graphile, and Hasura.</p><p><br></p><p>Requirements\tGraphile\tHasura</p><p>Open Source\t\u2705\t\u2705</p><p>Reflected GraphQL Schema\t\u2705\t\u2705</p><p>Reflected Resolvers\t\u2705\t\u2705</p><p>Always up-to-date\t\u2705\t\u2705</p><p>Performant\t\u2705\t\u2705</p><p>We found both options to be largely viable for the core feature set.</p><p><br></p><p>Which left us with one final hang-up: we host free-tier projects on VMs with 1 GB of memory. After tallying the resources reserved for PostgreSQL, PostgREST, Kong, GoTrue, and a handful of smaller services, we were left with a total memory budget of ... 0 MB \ud83d\ude2c. Unsurprisingly, our pathological memory target disqualified any option that required launching another process in those VMs.</p><p><br></p><p>For that reason, we decided to invest in a lightweight alternative that runs in the database, and can be exposed over HTTP using the existing PostgREST deployments' RPC functionality.</p><p><br></p><p>By our most conservative estimate, that reduces the platform's memory requirements by 525 TB/hours every month, saving \ud83d\udcb0 and \ud83c\udf33.</p><h2>Design</h2><p>As a native PostgreSQL extension, pg_graphl is written in a combination of C and SQL. Each GraphQL query is parsed, validated, and transpiled to SQL, all within the database.</p><p><br></p><p>Each GraphQL request is resolved by a single SQL statement. That SQL statement aggregates requested data as a JSON document to return to the caller. This approach results in blazing fast response times, avoids the N+1 query problem, and hits the theoretical minimum achievable network IO overhead of any GraphQL to SQL resolver. No special permissions are required for the PostgreSQL role executing queries, so pg_graphql is fully compatible with your existing row level security policies.</p><ol><li><p>Embedding the GraphQL server directly in the database allows us to leverage PostgreSQL's built-in solutions for common challenges:</p></li><li><p>Caching \u2192 PREPARE STATEMENT</p></li><li><p>Errors \u2192 RAISE EXCEPTION</p></li><li><p>Bad Data \u2192 ROLLBACK</p></li><li><p>Authorization \u2192 CREATE POLICY</p></li></ol><p>Similarly, pg_graphql benefits from PostgreSQL's strong ACID guarantees and can expose them through its API.</p><p><br></p><p>Ever wanted to execute multiple operations in a single transaction? Each request is managed in a single transaction so with a multi-operation GraphQL request and pg_graphql, that behavior falls out for free!</p><p><br></p><p>Schema Reflection</p><p>As a limited example of how the reflection engine works, here's how it converts a single table into a full GraphQL schema.</p><h3>schema.sql</h3><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>create table account(\n    id serial primary key,\n    email varchar(255) not null,\n    created_at timestamp not null,\n    updated_at timestamp not null\n);</code></pre></div><p>Where Query type's account field selects a single account by its globally unique ID and allAccounts enables pagination via the relay connections specification. Under the SQL hood, iterating through pages is handled using keyset pagination giving consistent retrieval times on every page.</p><p><br></p><p>For a more complete examples with relationships, enums, and more exotic types check out the reflection doc.</p><p><br></p><p>source : <a href=\"https://supabase.com/blog/pg-graphql\">https://supabase.com/blog/pg-graphql</a></p><p><a href=\"https://supabase.github.io/pg_graphql/\">https://supabase.github.io/pg_graphql/</a></p>","title":"pg_graphql: A GraphQL extension for PostgreSQL","slug":"pggraphql-a-graphql-extension-for-postgresql-6wwb"}